# Демонстрация использования СI/CD для разворачивания Serverless-приложений в Yandex Cloud

В этом примере демонстрируется тестовое приложение, которое разворачивается в Yandex Cloud на serverless-компонентах. Процесс сборки, тестирования и деплоя приложения полностью автоматизирован с помощью GitHub Actions.

## Используемые сервисы и технологии
* [GitHub Actions](https://docs.github.com/actions) - для автоматизации процессов
* [Docker](https://www.docker.com/) - для контейнеризации приложения
* [Yandex Container Registry](https://cloud.yandex.ru/docs/container-registry/) - для хранения Docker-образа приложения
* [Yandex Serverless Containers](https://cloud.yandex.ru/docs/serverless-containers/) - для развертывания приложения в бессерверном режиме
* [Yandex API Gateway](https://cloud.yandex.ru/docs/api-gateway/) - отвечает за прием трафика в приложении
* [Yandex Database](https://cloud.yandex.ru/docs/ydb/) в режиме Serverless Document API - для хранения данных приложения
* [Yandex Lockbox](https://cloud.yandex.ru/docs/lockbox/) - для хранения и доставки секретов приложения

## Как развернуть демо-приложение у себя
Для того, чтобы самостоятельно развернуть этот пример, вам потребуется репозиторий в GitHub и аккаунт в Yandex Cloud.

Локально должны быть установлены и настроены приложения и утилиты:
* [CLI Yandex Cloud](https://cloud.yandex.ru/docs/cli/)
* Python 3.8
* Библиотеки python, перечисленные в [application/requirements.txt](application/requirements.txt)
* [JQ](https://stedolan.github.io/jq/manual/)

Также обратите внимание, что сервис Yandex Lockbox на данный момент предоставляется в режиме [Preview](https://cloud.yandex.ru/docs/overview/concepts/launch-stages). Для использования сервисе в своем облаке необходимо [запросить доступ](https://cloud.yandex.ru/services/lockbox#preview-form).

## Первоначальная настройка
1. Скопируйте содержимое этой директории в корень своего репозитория на GitHub
2. Для развертывания базовой инфраструктуры в корне репозитория выполните команду
  `YC_CLOUD_ID=<идентификатор вашего облака> ./bootstrap.sh`
3. В конце выполнения скрипт bootstrap.sh предложит вам [добавить секреты](https://docs.github.com/en/actions/security-guides/encrypted-secrets) в вашем GitHub-репозитории
4. В случае успешного выполнения bootstrap-скрипта, в вашем облаке будут созданы новые директории, а в каталоге `config` рабочей копии вашего репозитория появится четыре YAML-файла: `infra.yaml`, `feature.yaml`, `testing.yaml` и `prod.yaml`. Эти файлы необходимо закоммитить в ваш репозиторий и опубликовать в ветке main
После выполнения этих шагов в вашем репозитории запустится процесс релиза первой версии приложения

## О приложении
В этом демонстрационном проекте реализовано простое web-приложение на [Django](https://www.djangoproject.com/), имитирующее корзину товаров e-commerce сервиса.

В базе данных хранятся описания товаров, база наполняется тестовыми данными из bootstrap-скрипта. Состояние корзины товаров сервис хранит в сессии пользователя.

Django-приложение разворачивается в Serverless-контейнере, доставка секретов в приложение осуществляется безопасно с помощью сервиса Lockbox. API Gateway принимает запросы от пользователей и проксирует их в контейнер приложения.

## Окружения
В этом примере мы используем три окружения для деплоя нашего приложения:
* **prod** - продуктовое окружение, которое видят пользователи
* **testing** - тестовое окружение, в котором приложение тестируется перед релизом в **prod**
* **feature** - окружение, использующееся в процессе разработки. В этом окружении разворачиваются временные стенды с копией приложения для отладки и проверки pull request'ов

Для каждого из окружений в bootstrap-скрипте создается отдельный каталог в Yandex Cloud, а так же отдельный набор статических ресурсов - база данных, сервисные аккаунты и т.д. Таким образом все окружения изолированы друг от друга на уровне настроек [IaM](https://cloud.yandex.ru/docs/iam/).

Окружения **prod** и **testing** содержат в себе по одному развернутому стенду, а в окружении **feature** может быть развернуто сразу несколько стендов, работающих с общей БД.

Дополнительно в проекте используется общий каталог infra - в него публикуются все собранные Docker-образы приложения. Сервисные аккаунты окружений prod, testing и feature имеют ограниченные права в infra-каталоге, которых достаточно для того, чтобы использовать образы из infra-каталога. Публикация образов в infra-каталог осуществляется от отдельного сервисного аккаунта builder.

## Автоматизированные процессы
### Развертывание feature-стенда из PR
Реализовано в действиях [Deploy feature stand](.github/workflows/deploy-feature-stand.yaml) и [Delete feature stand](.github/workflows/delete-feature-stand.yaml).

При публикации pull request'а в ветку main, в GitHub будет автоматически запущен workflow, разворачивающий отдельный стенд приложения в окружении **feature**. Изменения в PR автоматически докатываются в развернутый стенд. После закрытия PR стенд автоматически удаляется. 

Процесс развертывания выглядит следующим образом:
* Сборка образа из ветки
* Деплой собранного образа в окружение feature: в каталоге создаются контейнер и API Gateway с номером PR в названии
* e2e-тестирование стенда - на данный момент командой `curl` мы проверяем доступность главной страницы приложения
* Публикация ссылки на развернутый стенд: ссылка будет опубликована автоматически в комментариях к PR

### Релиз приложения
Реализован в действии [Release application](.github/workflows/release.yaml).

При публикации изменений в ветку `main` (при влитии PR или прямом пуше в main) автоматически запустится процесс релиза приложения на основные стенды. Процесс выглядит так:
* Вычисление номера релиза и тегирование последнего коммита этим номером
* Сборка docker-образа для релиза
* Деплой собранного образа в окружение testing
* e2e-тестирование testing-стенда
* Деплой собранного образа в окружение prod
* e2e-тестирование prod-стенда

## Вспомогательные workflow
Инфраструктура GitHub Actions позволяет описывать [переиспользуемые workflow](https://docs.github.com/en/actions/using-workflows/reusing-workflows). Вы можете использовать workflow, подготовленные другими участниками [сообщества](https://github.com/marketplace?type=actions), либо самостоятельно реализовать локальные переиспользуемые "кирпичики" для описания действий над своим репозиторием.

В этом примере мы используем некоторое количество GitHub Actions от сообщества:
* [yc-actions](https://github.com/yc-actions) - коллекция готовых действий для управления ресурсами в Yandex Cloud
* [actions/checkout](https://github.com/actions/checkout) - стандартное действие для вытягивания кода репозитория в workflow
* [mathieudutour/github-tag-action](https://github.com/mathieudutour/github-tag-action) - для тегирования релизов приложения номерами версий
* [frenck/action-setup-yq](https://github.com/frenck/action-setup-yq) - быстрый способ настроить утилиту [yq](https://github.com/mikefarah/yq) в workflow
* [actions/setup-python](https://github.com/actions/setup-python) - действие для подготовки python-окружения
* [cuchi/jinja2-action](https://github.com/cuchi/jinja2-action) - позволяет шаблонизировать файлы прямо в процессе исполнения workflow с помощью [jinja](https://jinja.palletsprojects.com/en/3.1.x/)

Также мы реализовали несколько своих переиспользуемых workflow для этого демонстрационного проекта:
* [build.yaml](.github/workflows/build.yaml) - собирает наше приложение в docker-образ и публикует образ в Yandex Container Registry
* [deploy-stage.yaml](.github/workflows/deploy-stage.yaml) - деплоит приложение на указанный стенд, запускает e2e-тест стенда
* [delete-stage.yaml](.github/workflows/delete-stage.yaml) - удаляет выбранный стенд
* [pr-comment.yaml](.github/workflows/pr-comment.yaml) - добавляет или обновляет комментарий к pull request